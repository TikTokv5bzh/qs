<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>لعبة الكلمات المتقاطعة - نسخة الجوال</title>
    <style>
        /* CSS Styles for Mobile */
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px; /* Reduced padding for mobile */
            direction: rtl;
            -webkit-text-size-adjust: 100%; /* Prevent text resizing on orientation change */
            touch-action: manipulation; /* Improve touch responsiveness */
        }

        h1 {
            color: #333;
            font-size: 1.5em; /* Slightly smaller title for mobile */
            margin-bottom: 10px;
        }

        #game-container {
            display: flex;
            flex-direction: column; /* Stack grid and clues vertically on mobile */
            gap: 15px; /* Reduced gap */
            align-items: center; /* Center items */
            width: 100%;
            max-width: 400px; /* Max width for the game area on mobile */
            margin: 0 auto; /* Center the game container */
        }

        #crossword-grid-container {
            width: 100%;
            overflow-x: auto; /* Allow horizontal scrolling for grid if it's too wide */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            padding-bottom: 10px; /* Space for scrollbar if needed */
        }

        #crossword-grid {
            display: grid;
            /* Grid columns will be set by JS */
            border: 1px solid #555; /* Slightly thinner border */
            background-color: #fff;
            margin: 0 auto; /* Center grid if it's narrower than container */
        }

        .grid-cell {
            width: calc( (100vw - 40px - ( ( /*cols_placeholder*/ 5 - 1) * 1px) ) / /*cols_placeholder*/ 5 ); /* Responsive cell width, adjust cols_placeholder */
            height: calc( (100vw - 40px - ( ( /*cols_placeholder*/ 5 - 1) * 1px) ) / /*cols_placeholder*/ 5 ); /* Responsive cell height */
            max-width: 45px; /* Max cell size */
            max-height: 45px; /* Max cell size */
            min-width: 28px; /* Min cell size */
            min-height: 28px; /* Min cell size */
            border: 0.5px solid #ccc; /* Thinner border for cells */
            text-align: center;
            font-size: clamp(12px, 4vw, 18px); /* Responsive font size */
            line-height: calc( (100vw - 40px - ( ( /*cols_placeholder*/ 5 - 1) * 1px) ) / /*cols_placeholder*/ 5 ); /* Responsive line height */
            max-height: 45px; /* Match max-height */
            box-sizing: border-box;
            background-color: white;
            position: relative;
        }

        .grid-cell.black {
            background-color: black;
        }

        .grid-cell input {
            width: 100%;
            height: 100%;
            border: none;
            text-align: center;
            font-size: inherit;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            outline: none;
            background-color: transparent;
            caret-color: #007bff; /* Visible cursor */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on iOS */
        }

        .cell-number {
            position: absolute;
            top: 1px;
            left: 1px;
            font-size: clamp(7px, 2vw, 9px); /* Responsive number size */
            color: #555;
            line-height: 1;
            pointer-events: none; /* Allow clicks to pass through to input */
        }

        #clues-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%; /* Full width on mobile */
        }

        .clue-section {
            background-color: #fff;
            padding: 10px; /* Reduced padding */
            border-radius: 6px; /* Slightly smaller radius */
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .clue-section h2 {
            margin-top: 0;
            font-size: 1.1em; /* Slightly smaller clue title */
            color: #555;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
            margin-bottom: 8px;
        }

        .clue-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 150px; /* Limit height and allow scrolling for clues */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .clue-list li {
            margin-bottom: 6px;
            font-size: clamp(12px, 3.5vw, 15px); /* Responsive clue text */
            padding: 2px 0;
        }

        #controls {
            margin-top: 15px;
            display: grid; /* Use grid for button layout on mobile */
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Responsive buttons */
            gap: 8px;
            width: 100%;
        }

        #controls button {
            padding: 12px 10px; /* Adjusted padding for touch targets */
            font-size: clamp(13px, 3.8vw, 16px); /* Responsive button text */
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #controls button:active { /* Feedback on tap */
            background-color: #0056b3;
        }

        /* Custom modal for alerts */
        .custom-modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        .custom-modal-content {
            background-color: #fff;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 300px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .custom-modal-content p {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        .custom-modal-content button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>لعبة الكلمات المتقاطعة</h1>

    <div id="game-container">
        <div id="crossword-grid-container">
            <div id="crossword-grid">
                </div>
        </div>

        <div id="clues-container">
            <div class="clue-section">
                <h2>الأفقي:</h2>
                <ul id="across-clues" class="clue-list">
                    </ul>
            </div>
            <div class="clue-section">
                <h2>العمودي:</h2>
                <ul id="down-clues" class="clue-list">
                    </ul>
            </div>
        </div>
    </div>

    <div id="controls">
        <button id="check-button">تحقق</button>
        <button id="reveal-letter-button">كشف حرف</button>
        <button id="reveal-word-button">كشف كلمة</button>
        <button id="reset-button">إعادة</button>
    </div>

    <div id="customAlertModal" class="custom-modal">
        <div class="custom-modal-content">
            <p id="customAlertMessage"></p>
            <button id="customAlertOkButton">موافق</button>
        </div>
    </div>

    <script>
        // JavaScript Code (Mostly similar to PC version, with adjustments for mobile)
        document.addEventListener('DOMContentLoaded', function() {
            const gridContainer = document.getElementById('crossword-grid');
            const acrossCluesList = document.getElementById('across-clues');
            const downCluesList = document.getElementById('down-clues');

            // تعريف بسيط للغز (كمثال)
            const puzzleLayout = [
                [0, 0, 0, 1, 0],
                [0, 1, 0, 1, 0],
                [0, 0, 0, 0, 0],
                [0, 1, 0, 1, 0],
                [0, 0, 0, 1, 0]
            ];

            const puzzleData = {
                across: [
                    { number: 1, clue: "عاصمة فرنسا", answer: "باريس", row: 0, col: 0, length: 3 },
                    { number: 3, clue: "حيوان أليف", answer: "قطة", row: 2, col: 0, length: 3},
                    { number: 4, clue: "عكس كلمة 'تحت'", answer: "فوق", row: 4, col: 0, length: 3}
                ],
                down: [
                    { number: 1, clue: "عاصمة مصر", answer: "قاهرة", row: 0, col: 0, length: 5 },
                    { number: 2, clue: "لون السماء", answer: "ازرق", row: 0, col: 2, length: 5 }
                ]
            };

            const rows = puzzleLayout.length;
            const cols = puzzleLayout[0].length;

            // Update CSS variable for cell size calculation
            // This is a placeholder. For a dynamic grid, this needs to be set based on actual 'cols'.
            // We will set grid-template-columns directly in JS for better control.
            // document.documentElement.style.setProperty('--grid-columns', cols);

            // Calculate cell size based on viewport width and number of columns
            const screenPadding = 20; // Total padding (10px left + 10px right)
            const gridBorderWidth = 2; // Total border width for the grid container
            const cellBorderWidth = 1; // Total border for a cell (0.5px on each side)
            
            // Calculate available width for the grid content (cells + internal borders)
            // Subtract game-container padding, grid-container padding, and grid border
            // Max width of game container is 400px.
            const gameContainerMaxWidth = 400;
            const availableWidthForGrid = Math.min(window.innerWidth - screenPadding, gameContainerMaxWidth - gridBorderWidth);
            
            // Calculate cell size
            // Total width taken by cell borders = (cols - 1) * cellBorderWidth (for internal borders)
            let cellSize = (availableWidthForGrid - ((cols - 1) * 0.5 * 2)) / cols; // 0.5px border on each side
            cellSize = Math.max(28, Math.min(cellSize, 45)); // Apply min/max cell size

            gridContainer.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;


            let cellNumber = 1;
            const numberedCells = {};

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    // Apply calculated cell size
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.style.lineHeight = `${cellSize}px`;


                    if (puzzleLayout[r][c] === 1) {
                        cell.classList.add('black');
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text'; // Use 'text' for better mobile keyboard support initially
                        input.setAttribute('autocapitalize', 'off');
                        input.setAttribute('autocorrect', 'off');
                        input.setAttribute('autocomplete', 'off');
                        input.setAttribute('spellcheck', 'false');
                        input.maxLength = 1;
                        input.dataset.row = r;
                        input.dataset.col = c;

                        input.addEventListener('input', (e) => {
                            // Automatically move to next input on entry
                            if (e.target.value.length === 1) {
                                const nextInput = findNextInput(e.target, 'any'); // Try any direction first
                                if (nextInput) {
                                    nextInput.focus();
                                }
                            }
                        });
                        input.addEventListener('keydown', (e) => handleKeyDown(e, input));
                        input.addEventListener('focus', (e) => {
                             // Highlight current clue
                             highlightClueForCell(parseInt(e.target.dataset.row), parseInt(e.target.dataset.col));
                        });


                        cell.appendChild(input);

                        let isAcrossStart = (c === 0 || (puzzleLayout[r][c-1] === 1)) && (c + 1 < cols && puzzleLayout[r][c+1] === 0);
                        let isDownStart = (r === 0 || (puzzleLayout[r-1][c] === 1)) && (r + 1 < rows && puzzleLayout[r+1][c] === 0);

                        if(isAcrossStart || isDownStart) {
                            const numberSpan = document.createElement('span');
                            numberSpan.classList.add('cell-number');
                            numberSpan.textContent = cellNumber;
                            cell.appendChild(numberSpan);
                            numberedCells[`${r}-${c}`] = cellNumber;
                            cellNumber++;
                        }
                    }
                    gridContainer.appendChild(cell);
                }
            }

            puzzleData.across.forEach(clue => {
                const listItem = document.createElement('li');
                const cellKey = `${clue.row}-${clue.col}`;
                const displayNum = numberedCells[cellKey] || clue.number;
                listItem.textContent = `${displayNum}. ${clue.clue} (${clue.answer.length} ح)`; // Shorter "حروف"
                listItem.dataset.answer = clue.answer;
                listItem.dataset.row = clue.row;
                listItem.dataset.col = clue.col;
                listItem.dataset.length = clue.length;
                listItem.dataset.direction = 'across';
                listItem.addEventListener('click', () => focusOnClueStart(clue.row, clue.col, 'across', clue.length));
                acrossCluesList.appendChild(listItem);
            });

            puzzleData.down.forEach(clue => {
                const listItem = document.createElement('li');
                const cellKey = `${clue.row}-${clue.col}`;
                const displayNum = numberedCells[cellKey] || clue.number;
                listItem.textContent = `${displayNum}. ${clue.clue} (${clue.answer.length} ح)`;
                listItem.dataset.answer = clue.answer;
                listItem.dataset.row = clue.row;
                listItem.dataset.col = clue.col;
                listItem.dataset.length = clue.length;
                listItem.dataset.direction = 'down';
                listItem.addEventListener('click', () => focusOnClueStart(clue.row, clue.col, 'down', clue.length));
                downCluesList.appendChild(listItem);
            });

            // Custom Alert Modal
            const alertModal = document.getElementById('customAlertModal');
            const alertMessage = document.getElementById('customAlertMessage');
            const alertOkButton = document.getElementById('customAlertOkButton');

            function showAlert(message) {
                alertMessage.textContent = message;
                alertModal.style.display = 'flex';
            }
            alertOkButton.addEventListener('click', () => {
                alertModal.style.display = 'none';
            });
            // Close modal if user clicks outside of it
            window.addEventListener('click', (event) => {
                if (event.target == alertModal) {
                    alertModal.style.display = "none";
                }
            });


            document.getElementById('check-button').addEventListener('click', checkAnswers);
            document.getElementById('reveal-letter-button').addEventListener('click', () => revealHint('letter'));
            document.getElementById('reveal-word-button').addEventListener('click', () => revealHint('word'));
            document.getElementById('reset-button').addEventListener('click', resetGrid);

            let currentDirection = 'across'; // Default direction

            function focusOnClueStart(row, col, direction, length) {
                const firstInput = gridContainer.querySelector(`input[data-row='${row}'][data-col='${col}']`);
                if (firstInput) {
                    firstInput.focus();
                    currentDirection = direction; // Set current direction based on clicked clue
                    highlightClueCells(row, col, length, direction, true);
                }
                 // Highlight the clue in the list
                document.querySelectorAll('.clue-list li').forEach(li => li.style.fontWeight = 'normal');
                const targetClueElement = document.querySelector(`.clue-list li[data-row='${row}'][data-col='${col}'][data-direction='${direction}']`);
                if (targetClueElement) {
                    targetClueElement.style.fontWeight = 'bold';
                }
            }

            function highlightClueForCell(row, col) {
                // Clear previous highlights
                document.querySelectorAll('.clue-list li').forEach(li => li.style.fontWeight = 'normal');
                document.querySelectorAll('#crossword-grid input').forEach(inp => inp.style.backgroundColor = 'transparent');


                // Find and highlight current across clue
                const acrossClue = puzzleData.across.find(c =>
                    row === c.row && col >= c.col && col < c.col + c.length
                );
                if (acrossClue) {
                    const acrossClueElement = document.querySelector(`.clue-list li[data-row='${acrossClue.row}'][data-col='${acrossClue.col}'][data-direction='across']`);
                    if (acrossClueElement) acrossClueElement.style.fontWeight = 'bold';
                    highlightClueCells(acrossClue.row, acrossClue.col, acrossClue.length, 'across', false);
                }

                // Find and highlight current down clue
                const downClue = puzzleData.down.find(c =>
                    col === c.col && row >= c.row && row < c.row + c.length
                );
                if (downClue) {
                     const downClueElement = document.querySelector(`.clue-list li[data-row='${downClue.row}'][data-col='${downClue.col}'][data-direction='down']`);
                    if (downClueElement) downClueElement.style.fontWeight = 'bold';
                    highlightClueCells(downClue.row, downClue.col, downClue.length, 'down', false);
                }

                // Prioritize currentDirection if cell is part of both
                if (acrossClue && downClue) {
                    if (currentDirection === 'across') {
                         highlightClueCells(acrossClue.row, acrossClue.col, acrossClue.length, 'across', true);
                    } else {
                         highlightClueCells(downClue.row, downClue.col, downClue.length, 'down', true);
                    }
                } else if (acrossClue) {
                     highlightClueCells(acrossClue.row, acrossClue.col, acrossClue.length, 'across', true);
                } else if (downClue) {
                     highlightClueCells(downClue.row, downClue.col, downClue.length, 'down', true);
                }
                 const currentInput = gridContainer.querySelector(`input[data-row='${row}'][data-col='${col}']`);
                 if(currentInput) currentInput.style.backgroundColor = '#e0e8f0'; // Light blue for current cell

            }


            function highlightClueCells(startRow, startCol, length, direction, isPrimary) {
                 for (let i = 0; i < length; i++) {
                    let r = startRow;
                    let c = startCol;
                    if (direction === 'across') {
                        c += i;
                    } else {
                        r += i;
                    }
                    const cellInput = gridContainer.querySelector(`input[data-row='${r}'][data-col='${c}']`);
                    if (cellInput) {
                        cellInput.style.backgroundColor = isPrimary ? '#cce5ff' : '#f0f8ff'; // Different shades for primary/secondary highlight
                    }
                }
            }


            function findNextInput(currentInput, preferredDirection = currentDirection) {
                let { row, col } = currentInput.dataset;
                row = parseInt(row);
                col = parseInt(col);
                let nextInput = null;

                // Try preferred direction first
                if (preferredDirection === 'across') {
                    if (col + 1 < cols) {
                        nextInput = gridContainer.querySelector(`input[data-row='${row}'][data-col='${col + 1}']`);
                    }
                } else if (preferredDirection === 'down') {
                    if (row + 1 < rows) {
                        nextInput = gridContainer.querySelector(`input[data-row='${row + 1}'][data-col='${col}']`);
                    }
                }

                // If no input in preferred direction or preferredDirection is 'any', try the other direction or scan
                if (!nextInput || preferredDirection === 'any') {
                    if (preferredDirection !== 'down' && row + 1 < rows) { // try down if not already tried
                         nextInput = gridContainer.querySelector(`input[data-row='${row + 1}'][data-col='${col}']`);
                    }
                    if (!nextInput && preferredDirection !== 'across' && col + 1 < cols) { // try across if not already tried
                        nextInput = gridContainer.querySelector(`input[data-row='${row}'][data-col='${col + 1}']`);
                    }
                    // If still no input, scan for the very next available input cell by cell, row by row
                    if (!nextInput) {
                        const allInputs = Array.from(gridContainer.querySelectorAll('input'));
                        const currentIndex = allInputs.indexOf(currentInput);
                        if (currentIndex !== -1 && currentIndex + 1 < allInputs.length) {
                            nextInput = allInputs[currentIndex + 1];
                        }
                    }
                }
                return nextInput && !nextInput.parentElement.classList.contains('black') ? nextInput : null;
            }


            function handleKeyDown(event, inputElement) {
                const row = parseInt(inputElement.dataset.row);
                const col = parseInt(inputElement.dataset.col);
                let nextRow = row;
                let nextCol = col;
                let nextInput = null;

                // Toggle direction on space or enter if cell is an intersection
                if (event.key === ' ' || event.key === 'Enter') {
                     event.preventDefault(); // Prevent space from being typed or form submission
                     const isAcross = puzzleData.across.some(c => c.row === row && col >= c.col && col < c.col + c.length);
                     const isDown = puzzleData.down.some(c => c.col === col && row >= c.row && row < c.row + c.length);
                     if (isAcross && isDown) {
                         currentDirection = (currentDirection === 'across') ? 'down' : 'across';
                         highlightClueForCell(row, col); // Re-highlight based on new direction
                     }
                     return;
                }


                switch (event.key) {
                    case 'ArrowUp':
                        nextRow = Math.max(0, row - 1);
                        currentDirection = 'down';
                        event.preventDefault();
                        break;
                    case 'ArrowDown':
                        nextRow = Math.min(rows - 1, row + 1);
                        currentDirection = 'down';
                        event.preventDefault();
                        break;
                    case 'ArrowLeft':
                        nextCol = Math.max(0, col - 1);
                        currentDirection = 'across';
                        event.preventDefault();
                        break;
                    case 'ArrowRight':
                        nextCol = Math.min(cols - 1, col + 1);
                        currentDirection = 'across';
                        event.preventDefault();
                        break;
                    case 'Backspace':
                        if (inputElement.value === '') {
                            const prevInput = findPrevInput(inputElement);
                            if (prevInput) {
                                prevInput.focus();
                                prevInput.value = '';
                            }
                            event.preventDefault();
                        }
                        // Allow default backspace behavior if there's text in the input
                        return;
                    default:
                        // For other keys, especially character input, do nothing extra here
                        // The 'input' event will handle moving to the next cell
                        return;
                }

                nextInput = gridContainer.querySelector(`input[data-row='${nextRow}'][data-col='${nextCol}']`);
                if (nextInput && !nextInput.parentElement.classList.contains('black')) {
                    nextInput.focus();
                }
            }

            function findPrevInput(currentInput) {
                let { row, col } = currentInput.dataset;
                row = parseInt(row);
                col = parseInt(col);
                let prevInput = null;

                if (currentDirection === 'across') {
                    if (col - 1 >= 0) {
                         prevInput = gridContainer.querySelector(`input[data-row='${row}'][data-col='${col - 1}']`);
                    }
                } else { // currentDirection === 'down'
                     if (row - 1 >= 0) {
                        prevInput = gridContainer.querySelector(`input[data-row='${row - 1}'][data-col='${col}']`);
                    }
                }
                // Fallback if no previous in current direction or at start of a word
                 if (!prevInput) {
                    const allInputs = Array.from(gridContainer.querySelectorAll('input:not([disabled]))'));
                    const currentIndex = allInputs.indexOf(currentInput);
                    if (currentIndex > 0) {
                        prevInput = allInputs[currentIndex - 1];
                    }
                }
                return prevInput && !prevInput.parentElement.classList.contains('black') ? prevInput : null;
            }


            function checkAnswers() {
                console.log("التحقق من الإجابات...");
                let allCorrect = true;
                let firstIncorrectInput = null;

                document.querySelectorAll('#crossword-grid input').forEach(inp => {
                    inp.style.backgroundColor = 'transparent'; // Reset background
                });


                puzzleData.across.forEach(clue => {
                    let userAnswer = "";
                    for (let i = 0; i < clue.length; i++) {
                        const cellInput = gridContainer.querySelector(`input[data-row='${clue.row}'][data-col='${clue.col + i}']`);
                        if (cellInput) {
                            userAnswer += cellInput.value.toUpperCase();
                        }
                    }
                    if (userAnswer.toLowerCase() === clue.answer.toLowerCase()) {
                        for (let i = 0; i < clue.length; i++) {
                            const cellInput = gridContainer.querySelector(`input[data-row='${clue.row}'][data-col='${clue.col + i}']`);
                            if(cellInput) cellInput.style.backgroundColor = '#d4edda'; // Green for correct
                        }
                    } else {
                        allCorrect = false;
                        for (let i = 0; i < clue.length; i++) {
                            const cellInput = gridContainer.querySelector(`input[data-row='${clue.row}'][data-col='${clue.col + i}']`);
                            if (cellInput && cellInput.value !== '' && cellInput.value.toUpperCase() !== clue.answer[i].toUpperCase()) {
                                cellInput.style.backgroundColor = '#f8d7da'; // Red for incorrect
                                if (!firstIncorrectInput) firstIncorrectInput = cellInput;
                            } else if (cellInput && cellInput.value === '') {
                                 if (!firstIncorrectInput) firstIncorrectInput = cellInput; // Also consider empty as incorrect for focusing
                            }
                        }
                    }
                });

                puzzleData.down.forEach(clue => {
                    let userAnswer = "";
                    for (let i = 0; i < clue.length; i++) {
                        const cellInput = gridContainer.querySelector(`input[data-row='${clue.row + i}'][data-col='${clue.col}']`);
                        if (cellInput) {
                            userAnswer += cellInput.value.toUpperCase();
                        }
                    }
                     if (userAnswer.toLowerCase() === clue.answer.toLowerCase()) {
                        for (let i = 0; i < clue.length; i++) {
                            const cellInput = gridContainer.querySelector(`input[data-row='${clue.row + i}'][data-col='${clue.col}']`);
                             if(cellInput && cellInput.style.backgroundColor !== '#f8d7da') cellInput.style.backgroundColor = '#d4edda';
                        }
                    } else {
                        allCorrect = false;
                        for (let i = 0; i < clue.length; i++) {
                            const cellInput = gridContainer.querySelector(`input[data-row='${clue.row + i}'][data-col='${clue.col}']`);
                            if (cellInput && cellInput.value !== '' && cellInput.value.toUpperCase() !== clue.answer[i].toUpperCase()) {
                                cellInput.style.backgroundColor = '#f8d7da';
                                if (!firstIncorrectInput) firstIncorrectInput = cellInput;
                            } else if (cellInput && cellInput.value === '') {
                                 if (!firstIncorrectInput) firstIncorrectInput = cellInput;
                            }
                        }
                    }
                });

                if(allCorrect) {
                    showAlert("رائع! لقد أجبت على جميع الأسئلة بشكل صحيح!");
                } else {
                    showAlert("بعض الإجابات غير صحيحة. حاول مرة أخرى!");
                    if (firstIncorrectInput) {
                        firstIncorrectInput.focus(); // Focus on the first incorrect cell
                    }
                }
            }

            function revealHint(type) {
                showAlert(`وظيفة "${type === 'letter' ? 'كشف حرف' : 'كشف كلمة'}" لم تبرمج بالكامل بعد.`);
            }

            function resetGrid() {
                console.log("إعادة تعيين اللوحة...");
                const inputs = gridContainer.querySelectorAll('input');
                inputs.forEach(input => {
                    input.value = '';
                    input.style.backgroundColor = 'transparent';
                    input.disabled = false;
                });
                document.querySelectorAll('#across-clues li, #down-clues li').forEach(li => {
                    li.style.fontWeight = 'normal';
                });
                showAlert("تم إعادة تعيين اللوحة.");
                const firstCell = gridContainer.querySelector('input');
                if(firstCell) firstCell.focus();
            }
            
            // Initial focus on the first cell
            const firstCellInput = gridContainer.querySelector('input');
            if (firstCellInput) {
                firstCellInput.focus();
            }
        });
    </script>
</body>
</html>

